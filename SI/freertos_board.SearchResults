---- traceMALLOC Matches (3 in 2 files) ----
FreeRTOS.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#ifndef traceMALLOC
FreeRTOS.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#define traceMALLOC( pvAddress, uiSize )
Heap_2.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        traceMALLOC(pvReturn, xWantedSize);
---- xPortGetFreeHeapSize() Matches (0 in 0 files) ----
---- xPortGetFreeHeapSize Matches (3 in 3 files) ----
Heap_2.c (c:\users\yk\desktop\代码\学习\freertos_board\os):size_t xPortGetFreeHeapSize(void)
Mpu_wrappers.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#define xPortGetFreeHeapSize			MPU_xPortGetFreeHeapSize
Portable.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):    size_t xPortGetFreeHeapSize(void) PRIVILEGED_FUNCTION;
---- size_t Matches (28 in 7 files) ----
Comfunc.h (c:\users\yk\desktop\代码\学习\freertos_board\user):#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
FreeRTOSConfig.h (c:\users\yk\desktop\代码\学习\freertos_board\project):#define configTOTAL_HEAP_SIZE		( ( size_t ) ( 17 * 1024 ) )    //内核总共可用RAM 
Heap_2.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    size_t xBlockSize;          /*<< The size of the free block. */
Heap_2.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )
Heap_2.c (c:\users\yk\desktop\代码\学习\freertos_board\os):static size_t xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;
Heap_2.c (c:\users\yk\desktop\代码\学习\freertos_board\os):size_t xBlockSize;																	\
Heap_2.c (c:\users\yk\desktop\代码\学习\freertos_board\os):void *pvPortMalloc(size_t xWantedSize)
Heap_2.c (c:\users\yk\desktop\代码\学习\freertos_board\os):size_t xPortGetFreeHeapSize(void)
Heap_2.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    xStart.xBlockSize = (size_t) 0;
Portable.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):        size_t xSizeInBytes;
Portable.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):    void *pvPortMalloc(size_t xSize) PRIVILEGED_FUNCTION;
Portable.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):    size_t xPortGetFreeHeapSize(void) PRIVILEGED_FUNCTION;
Portable.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):    size_t xPortGetMinimumEverFreeHeapSize(void) PRIVILEGED_FUNCTION;
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    size_t xQueueSizeInBytes;
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        volatile size_t xSize = sizeof(StaticQueue_t);
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        xQueueSizeInBytes = (size_t) 0;
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        xQueueSizeInBytes = (size_t) (uxQueueLength * uxItemSize);  /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):            if ((*ppucQueueStorage == NULL) && (xQueueSizeInBytes > (size_t) 0))
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        (void) memcpy((void *) pxQueue->pcWriteTo, pvItemToQueue, (size_t) pxQueue->uxItemSize);    /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        (void) memcpy((void *) pxQueue->u.pcReadFrom, pvItemToQueue, (size_t) pxQueue->uxItemSize); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        (void) memcpy((void *) pvBuffer, (void *) pxQueue->u.pcReadFrom, (size_t) pxQueue->uxItemSize); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        volatile size_t xSize = sizeof(StaticTask_t);
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):            pxNewTCB->pxStack = (StackType_t *) pvPortMallocAligned((((size_t) usStackDepth) * sizeof(StackType_t)), puxStackBuffer);   /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        pxStack = (StackType_t *) pvPortMallocAligned((((size_t) usStackDepth) * sizeof(StackType_t)), puxStackBuffer); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):            (void) memset(pxNewTCB->pxStack, (int) tskSTACK_FILL_BYTE, (size_t) usStackDepth * sizeof(StackType_t));
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    size_t x;
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    for (x = strlen(pcBuffer); x < (size_t) (configMAX_TASK_NAME_LEN - 1); x++)
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        volatile size_t xSize = sizeof(StaticTimer_t);
---- INCLUDE_vTaskPriorityGet Matches (1 in 1 files) ----
FreeRTOSConfig.h (c:\users\yk\desktop\代码\学习\freertos_board\project):#define INCLUDE_vTaskPriorityGet        1
---- INCLUDE_vTaskDelay Matches (6 in 4 files) ----
FreeRTOS.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#ifndef INCLUDE_vTaskDelay
FreeRTOS.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#define INCLUDE_vTaskDelay 0
FreeRTOSConfig.h (c:\users\yk\desktop\代码\学习\freertos_board\project):#define INCLUDE_vTaskDelay				1
Task.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include): * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if ( INCLUDE_vTaskDelay == 1 )
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#endif                          /* INCLUDE_vTaskDelay */
---- vPortStartFirstTask Matches (4 in 2 files) ----
Port.c (c:\users\yk\desktop\代码\学习\freertos_board\os):extern void vPortStartFirstTask(void);
Port.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    vPortStartFirstTask();
Portasm.s (c:\users\yk\desktop\代码\学习\freertos_board\os):	PUBLIC vPortStartFirstTask
Portasm.s (c:\users\yk\desktop\代码\学习\freertos_board\os):vPortStartFirstTask
---- configSUPPORT_STATIC_ALLOCATION Matches (49 in 10 files) ----
Event_groups.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Event_groups.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Event_groups.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Event_groups.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Event_groups.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Event_groups.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
FreeRTOS.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#ifndef configSUPPORT_STATIC_ALLOCATION
FreeRTOS.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#define configSUPPORT_STATIC_ALLOCATION 0
FreeRTOS.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
FreeRTOS.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
FreeRTOS.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
FreeRTOS.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( ( configASSERT_DEFINED == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 0 )
Queue.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 0 )
Queue.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Queue.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Semphr.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Semphr.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Semphr.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Semphr.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Semphr.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Semphr.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Semphr.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Semphr.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Task.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Task.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION != 1 ) )
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#error configSUPPORT_STATIC_ALLOCATION must be set to 1 in FreeRTOSConfig.h when the MPU is used.
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( ( configASSERT_DEFINED == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( ( configASSERT_DEFINED == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
Timers.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#if( configSUPPORT_STATIC_ALLOCATION == 1 )
Timers.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#endif                          /* configSUPPORT_STATIC_ALLOCATION */
---- prvIdleTask Matches (5 in 1 files) ----
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os): * void prvIdleTask( void *pvParameters );
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):static portTASK_FUNCTION_PROTO(prvIdleTask, pvParameters);
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    xReturn = xTaskGenericCreate(prvIdleTask, "IDLE", usIdleTaskStackSize, (void *) NULL, (tskIDLE_PRIORITY | portPRIVILEGE_BIT), &xIdleTaskHandle, pxIdleTaskStackBuffer, pxIdleTaskTCBBuffer, NULL);  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os): * void prvIdleTask( void *pvParameters );
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):static portTASK_FUNCTION(prvIdleTask, pvParameters)
---- vPortStartFirstTask Matches (4 in 2 files) ----
Port.c (c:\users\yk\desktop\代码\学习\freertos_board\os):extern void vPortStartFirstTask(void);
Port.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    vPortStartFirstTask();
Portasm.s (c:\users\yk\desktop\代码\学习\freertos_board\os):	PUBLIC vPortStartFirstTask
Portasm.s (c:\users\yk\desktop\代码\学习\freertos_board\os):vPortStartFirstTask
---- xTimerCreateTimerTask Matches (3 in 3 files) ----
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):            xReturn = xTimerCreateTimerTask();
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):BaseType_t xTimerCreateTimerTask(void)
Timers.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):    BaseType_t xTimerCreateTimerTask(void) PRIVILEGED_FUNCTION;
---- prvIdleTask Matches (5 in 1 files) ----
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os): * void prvIdleTask( void *pvParameters );
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):static portTASK_FUNCTION_PROTO(prvIdleTask, pvParameters);
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    xReturn = xTaskGenericCreate(prvIdleTask, "IDLE", usIdleTaskStackSize, (void *) NULL, (tskIDLE_PRIORITY | portPRIVILEGE_BIT), &xIdleTaskHandle, pxIdleTaskStackBuffer, pxIdleTaskTCBBuffer, NULL);  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os): * void prvIdleTask( void *pvParameters );
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):static portTASK_FUNCTION(prvIdleTask, pvParameters)
---- portTASK_FUNCTION_PROTO Matches (3 in 2 files) ----
Portmacro.h (c:\users\yk\desktop\代码\学习\freertos_board\os):#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os): * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):static portTASK_FUNCTION_PROTO(prvIdleTask, pvParameters);
---- vListInitialiseItem Matches (9 in 5 files) ----
Croutine.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        vListInitialiseItem(&(pxCoRoutine->xGenericListItem));
Croutine.c (c:\users\yk\desktop\代码\学习\freertos_board\os):        vListInitialiseItem(&(pxCoRoutine->xEventListItem));
List.c (c:\users\yk\desktop\代码\学习\freertos_board\os):void vListInitialiseItem(ListItem_t * const pxItem)
List.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include): * \page vListInitialiseItem vListInitialiseItem
List.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):    void vListInitialiseItem(ListItem_t * const pxItem) PRIVILEGED_FUNCTION;
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    vListInitialiseItem(&(pxTCB->xStateListItem));
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    vListInitialiseItem(&(pxTCB->xEventListItem));
Timers.c (c:\users\yk\desktop\代码\学习\freertos_board\os):            vListInitialiseItem(&(pxNewTimer->xTimerListItem));
---- cmd_echo Matches (2 in 1 files) ----
Debug.c (c:\users\yk\desktop\代码\学习\freertos_board\user):static void cmd_echo(char ch)
Debug.c (c:\users\yk\desktop\代码\学习\freertos_board\user):        cmd_echo(c);
---- MPU_xTaskGenericCreate Matches (1 in 1 files) ----
Mpu_wrappers.h (c:\users\yk\desktop\代码\学习\freertos_board\os\include):#define xTaskGenericCreate				MPU_xTaskGenericCreate
---- prvAllocateTCBAndStack Matches (3 in 1 files) ----
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):static TCB_t *prvAllocateTCBAndStack(const uint16_t usStackDepth, StackType_t * const puxStackBuffer,
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    pxNewTCB = prvAllocateTCBAndStack(usStackDepth, puxStackBuffer, (TCB_t *) pxTaskBuffer);    /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):static TCB_t *prvAllocateTCBAndStack(const uint16_t usStackDepth, StackType_t * const puxStackBuffer,
---- prvIdleTask Matches (5 in 1 files) ----
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os): * void prvIdleTask( void *pvParameters );
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):static portTASK_FUNCTION_PROTO(prvIdleTask, pvParameters);
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):    xReturn = xTaskGenericCreate(prvIdleTask, "IDLE", usIdleTaskStackSize, (void *) NULL, (tskIDLE_PRIORITY | portPRIVILEGE_BIT), &xIdleTaskHandle, pxIdleTaskStackBuffer, pxIdleTaskTCBBuffer, NULL);  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os): * void prvIdleTask( void *pvParameters );
Tasks.c (c:\users\yk\desktop\代码\学习\freertos_board\os):static portTASK_FUNCTION(prvIdleTask, pvParameters)
